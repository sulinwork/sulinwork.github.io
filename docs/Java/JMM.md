# JMM简介 

> Java Memory Model ：Java内存模型

## CPU多核并发缓存架构

![cpu架构图](../images/cpu_cache.png)

## JMM 内存模型

> ​		Java 内存模型就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致性的机制和规范。
>
> ​		Java内存模型规定了所有的变量都存储在主内存中，每个线程还有自己的工作内存，线程的工作内存中保存了该线程需要使用到的变量的主内存拷贝过来的副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写操作主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递需要自己的个工作内存和主内存之间进行数据同步。
>
> ​		而JMM就作用于工作内存和主内存之间数据同步过程。他规定了如何做数据同步已经什么时候做数据同步。

![JMM内存模型图](../images/jmm.webp)

> ​		在《深入理解Java虚拟机》中认为，如果一定要把主内存和工作内存对应到JVM内存结构的话，主内存对应于java堆中的对象实例数据部分，而工作内存对应虚拟机栈中的部分区域。
>
> **总结：JMM是一种规范，目的是为了解决由于多线程通过共享内存进行通讯时，存在的本地内存数据不一致、编译器优化代码指令重排序带来的问题**

# JMM 底层八大原子操作

> 主要是 主内存和工作内存之间的数据拷贝

- read（读取）：从主内存读取数据
- load（载入）：将主内存读取到的数据写入到工作内存
- use（使用）：从工作内存读取数据来计算
- assign（赋值）：将计算好的值重新赋值到工作内存中
- store（存储）：将工作内存数据写入到主内存
- write（写入）：将store过去的变量赋值给主内存中的变量
- lock（锁定）：将主内存变量加锁，标识为线程独占状态
- unlock（解锁）：将主内存变量解锁